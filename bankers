def bankers_algorithm(processes, resources, available, max_demand, allocation):
    n = len(processes)
    m = len(resources)

    # Calculate Need matrix
    need = [[max_demand[i][j] - allocation[i][j] for j in range(m)] for i in range(n)]

    finish = [False] * n
    safe_sequence = []
    work = available[:]

    print("\nNeed Matrix:")
    for i in range(n):
        print(f"P{i}: {need[i]}")

    while len(safe_sequence) < n:
        allocated = False
        for i in range(n):
            if not finish[i] and all(need[i][j] <= work[j] for j in range(m)):
                # This process can be safely executed
                print(f"\nProcess P{i} can be allocated. Work before: {work}")
                
                # Add allocation back to work
                for j in range(m):
                    work[j] += allocation[i][j]

                finish[i] = True
                safe_sequence.append(processes[i])
                allocated = True

                print(f"Process P{i} finished. Work after: {work}")
        
        if not allocated:  # No process could be allocated in this round
            print("\nSystem is in UNSAFE state! No Safe Sequence exists.")
            return None

    print("\nSystem is in SAFE state.")
    print(f"Safe Sequence: {' -> '.join(f'P{p}' for p in safe_sequence)}")
    return safe_sequence


# Example Usage
if __name__ == "__main__":
    processes = [0, 1, 2, 3, 4]
    resources = ['A', 'B', 'C']

    available = [3, 3, 2]

    max_demand = [
        [7, 5, 3],
        [3, 2, 2],
        [9, 0, 2],
        [2, 2, 2],
        [4, 3, 3]
    ]

    allocation = [
        [0, 1, 0],
        [2, 0, 0],
        [3, 0, 2],
        [2, 1, 1],
        [0, 0, 2]
    ]

    bankers_algorithm(processes, resources, available, max_demand, allocation)
