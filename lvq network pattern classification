import numpy as np

class LVQ:
    def __init__(self, n_prototypes_per_class=1, lr=0.3, seed=1):
        self.nppc = n_prototypes_per_class
        self.lr = lr
        np.random.seed(seed)
        self.prototypes = None
        self.labels = None

    def initialize(self, X, y):
        classes = np.unique(y)
        protos = []
        labels = []
        for c in classes:
            xc = X[y==c]
            idx = np.random.choice(len(xc), self.nppc, replace=True)
            for i in idx:
                protos.append(xc[i].copy())
                labels.append(c)
        self.prototypes = np.array(protos)
        self.labels = np.array(labels)

    def train(self, X, y, epochs=20):
        if self.prototypes is None:
            self.initialize(X,y)
        for ep in range(epochs):
            for xi, yi in zip(X, y):
                dists = np.linalg.norm(self.prototypes - xi, axis=1)
                j = np.argmin(dists)
                if self.labels[j] == yi:
                    self.prototypes[j] += self.lr * (xi - self.prototypes[j])
                else:
                    self.prototypes[j] -= self.lr * (xi - self.prototypes[j])
            self.lr *= 0.95

    def predict(self, X):
        preds = []
        for xi in X:
            dists = np.linalg.norm(self.prototypes - xi, axis=1)
            j = np.argmin(dists)
            preds.append(self.labels[j])
        return np.array(preds)

if __name__ == "__main__":
    X = np.array([[0,0],[0,1],[1,0],[1,1]], dtype=float)
    y = np.array([0,1,1,1])  # OR labels
    lvq = LVQ(n_prototypes_per_class=1, lr=0.5)
    lvq.initialize(X,y)
    lvq.train(X,y,epochs=30)
    print("Prototypes:", lvq.prototypes)
    print("Proto labels:", lvq.labels)
    print("Predictions:", lvq.predict(X))
    print("Accuracy:", (lvq.predict(X)==y).mean())
